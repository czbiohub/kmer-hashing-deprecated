param (
    // S3 path to read1 of the fastq/fasta file. If multiple files, 
    // can be pipe-separated e.g. sample1_01.fastq|sample1_02.fastq
    read1 string

    // S3 path to read2 of the fastq/fasta file. If multiple files, 
    // can be pipe-separated e.g. sample1_01.fastq|sample1_02.fastq
    read2 string

    // Identifier of the sample
    name string

    // Full s3 file location to put the sourmash signature
    output string

    // Size of kmer to use
    ksize = 21

    // Use 2**log2_sketch_size hashes
    log2_sketch_size = 10

    // number of processes
    threads = 4
)


val files = make("$/files")
val dirs = make("$/dirs")
val strings = make("$/strings")


val dashing = make("./dashing.rf")

// Split each read string by the pipe "|" to get individual s3 paths
val read1s = strings.Split(read1, "|")
val read2s = strings.Split(read2, "|")

// Create a file for each element in the `read1s`, `read2s` string array
// Now `r1`, `r1` are arrays of files
val r1 = [file(read1) | read1 <- read1s]
val r2 = [file(read2) | read2 <- read2s]


func Cat(files [file]) = 
    exec(image := "ubuntu") (catted file) {"
        cat {{files}} > {{catted}}
    "}

// Concatenate all R1 and R2 into a single file for dashing
reads := Cat(flatten([r1, r2]))

sketch := dashing.Sketch(reads, name, log2_sketch_size, ksize, threads)

@requires(cpu := 2)
val Main = dirs.Copy(sketch, output)